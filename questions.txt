Ruby on Rails

1. Quelles seraient les premières étapes à prendre pour refacto un projet où les
controllers sont trop longs?

> Identifier le code business dans les controlleurs pour le deplacer vers les
  models. Voir ensuite factoriser via des `concerns` pour les models


2. Qu'est-ce que le N+1 et comment l'éviter en Rails?

> Prenons l'exemple d'un blog. Chaque post peut avoir 0 ou N commentaires.

On definit une methode :

def comments_for_top_three_posts
  posts = Post.limit(3)
  posts.flat_map do |post|
    post.comments.to_a
  end
end

Pour chaque post nous allons requeter la base pour obtenir ses commentaires.
Trois requetes du type :

select * from comments where post_id = N

C'est ca le N+1.

Pour l'eviter, on utilise `l'eager loading` qui permet de charger les objects
rattaches en limitant le nombre de requetes :

def comments_for_top_three_posts
  posts = Post.includes(:comments).limit(3)
  posts.flat_map do |post|
    post.comments.to_a
  end
end

La requetes sera du type :

select * from comments where "post_id" IN (1, 2, 3)

3. D'un point de vue pratique, quel intérêt à utiliser des constantes dans une
app Rails? Quelles implémentations avez-vous vu/mis en place?

> Une constante est immutable ce qui garanti que sa valeur tout au long de
l'execution.
Mise en place dans le refacto ci-joint dans la class `Rule`

4. Décrivez une fonction de Ruby trop peu utilisée à votre goût

> `lambda`. Car elle permet d'apporter la souplesse du fonctionnel.

Architecture

1. Une entreprise veut créer un système de notification pour son site. Chaque
type de notification a besoin de 'variables' différentes: (x a aimé le projet de
y, le projet x vient d'être mis à jour, etc.) La base de données est en
PostgreSQL. Proposez une structure de données et une implémentation en back-end
qui permettrait d'être assez flexible tout en réduisant la possibilité de bugs
et de structures non conformes

>

On peut aussi envisager d'utiliser un validateur du message json
avec la gem 'json-schema' Ruby JSON Schema Validator

Modele de 'Notification'

recipient_id:   integer # qui recois
sender_id:      integer # qui envoi
read_at:        datetime # date de la lecture
action:         string   # description de l'action
notifiable_id   integer  # id de l'objet sur lequel s'applique la notif (polymorphic)
notifiable_type string   # description du type de la notif (eg. 'comment_notif')

# config/routes.rb
Rails.application.routes.draw do
  devise_for :users
  resources :notifications, only: [:index] do
    collection do
      post :notify
    end
  end
end

# app/models/notification.rb
class Notification < ApplicationRecord
  belongs_to :recipient, class_name: 'User'
  belongs_to :sender, class_name: 'User'
  belongs_to :notifiable, polymorphic: true

  scope :unread, -> { where(read_at: nil) }
end

# app/controllers/notifications_controller.rb
calss NotificationsController < ApplicationController
  def index
  end

  def notify
    check_params_validity(params)
    send_notif(params)
  end
end


2. Décrivez les objets et la structure de donnée que vous utiliseriez pour
implémenter un jeu de Touché-Coulé

> - Dimension du plateau
    Une longueur (int) / Une largeur (int)
    
  - Une collection de navires pour chaque joueur
    Une Hash avec pour clefs les tailles de navires et pour valeurs
    une collection de tuples correspondants a des coordonnees
    ex:
    {
      navires_1: [['B2'], ['D4']],
      navires_2: [['A2', 'A3'], ['C1', 'C2]]
      ...
    }

  - Une autre collection de navires pour chaque joueur representant
    les coups joues. Elle represente l'etat de la flotte adverse.
    
